name: Web Application CI/CD Pipeline

on:
  push:
    branches: [ main ]
    paths:
      - 'app/**'
      - 'components/**'
      - 'lib/**'
      - 'public/**'
      - 'styles/**'
      - '*.js'
      - '*.ts'
      - '*.tsx'
      - '*.json'
      - '*.config.*'
  pull_request:
    branches: [ main ]
    paths:
      - 'app/**'
      - 'components/**'
      - 'lib/**'
      - 'public/**'
      - 'styles/**'
      - '*.js'
      - '*.ts'
      - '*.tsx'
      - '*.json'
      - '*.config.*'
  workflow_dispatch:
    inputs:
      deploy_environment:
        description: 'Target deployment environment'
        required: false
        default: 'production'
        type: choice
        options:
        - production
        - staging
      skip_tests:
        description: 'Skip test execution (emergency deployments only)'
        required: false
        default: false
        type: boolean

permissions:
  contents: read
  pages: write
  id-token: write
  checks: write
  pull-requests: write

# Optimize for parallel execution while preventing conflicts
concurrency:
  group: webapp-cicd-${{ github.ref }}
  cancel-in-progress: true

env:
  NODE_VERSION: '18'
  CACHE_VERSION: 'v2'  # Increment to bust caches when needed

jobs:
  code-quality:
    name: Code Quality & Security Scan
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Required for proper diff analysis

      - name: Setup Node.js with comprehensive caching
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: |
            package-lock.json

      - name: Cache node_modules (60% build time reduction)
        uses: actions/cache@v3
        id: cache-deps
        with:
          path: |
            node_modules
            ~/.npm
          key: ${{ runner.os }}-node-${{ env.CACHE_VERSION }}-${{ hashFiles('package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-${{ env.CACHE_VERSION }}-
            ${{ runner.os }}-node-

      - name: Install dependencies
        if: steps.cache-deps.outputs.cache-hit != 'true'
        run: |
          npm ci --prefer-offline --no-audit --progress=false
          echo "Dependencies installed from scratch"

      - name: Cache ESLint results
        uses: actions/cache@v3
        with:
          path: .eslintcache
          key: ${{ runner.os }}-eslint-${{ env.CACHE_VERSION }}-${{ hashFiles('**/*.ts', '**/*.tsx', '**/*.js', '**/*.jsx') }}
          restore-keys: |
            ${{ runner.os }}-eslint-${{ env.CACHE_VERSION }}-

      - name: Run ESLint with caching
        run: |
          npx eslint . --ext .js,.jsx,.ts,.tsx --cache --cache-location .eslintcache --max-warnings 0
          echo "‚úÖ ESLint passed"

      - name: Cache TypeScript compilation
        uses: actions/cache@v3
        with:
          path: |
            .tsbuildinfo
            tsconfig.tsbuildinfo
          key: ${{ runner.os }}-typescript-${{ env.CACHE_VERSION }}-${{ hashFiles('**/*.ts', '**/*.tsx', 'tsconfig.json') }}

      - name: TypeScript type checking
        run: |
          npx tsc --noEmit --incremental
          echo "‚úÖ TypeScript compilation passed"

      - name: Security vulnerability scan
        run: |
          npm audit --audit-level=high
          echo "‚úÖ Security scan passed"

      - name: Upload code quality results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: code-quality-results
          path: |
            .eslintcache
            .tsbuildinfo
          retention-days: 7

  unit-tests:
    name: Unit Tests & Coverage
    runs-on: ubuntu-latest
    needs: code-quality
    if: ${{ !inputs.skip_tests }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js with caching
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Restore dependencies cache
        uses: actions/cache@v3
        with:
          path: |
            node_modules
            ~/.npm
          key: ${{ runner.os }}-node-${{ env.CACHE_VERSION }}-${{ hashFiles('package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-${{ env.CACHE_VERSION }}-

      - name: Install dependencies (if cache miss)
        run: |
          if [ ! -d "node_modules" ]; then
            npm ci --prefer-offline --no-audit --progress=false
          fi

      - name: Cache Jest results
        uses: actions/cache@v3
        with:
          path: |
            .jest-cache
            coverage
          key: ${{ runner.os }}-jest-${{ env.CACHE_VERSION }}-${{ hashFiles('**/*.test.*', '**/*.spec.*') }}

      - name: Run unit tests with coverage
        run: |
          npm test -- --coverage --cacheDirectory=.jest-cache --watchAll=false --passWithNoTests
          echo "‚úÖ Unit tests passed"

      - name: Upload coverage reports
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: coverage/
          retention-days: 30

  build-optimization:
    name: Build & Bundle Optimization
    runs-on: ubuntu-latest
    needs: [code-quality]
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js with caching
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Restore dependencies cache
        uses: actions/cache@v3
        with:
          path: |
            node_modules
            ~/.npm
          key: ${{ runner.os }}-node-${{ env.CACHE_VERSION }}-${{ hashFiles('package-lock.json') }}

      - name: Install dependencies (if cache miss)
        run: |
          if [ ! -d "node_modules" ]; then
            npm ci --prefer-offline --no-audit --progress=false
          fi

      - name: Cache Next.js build
        uses: actions/cache@v3
        with:
          path: |
            .next/cache
            .next/static
          key: ${{ runner.os }}-nextjs-${{ env.CACHE_VERSION }}-${{ hashFiles('**/*.js', '**/*.jsx', '**/*.ts', '**/*.tsx') }}
          restore-keys: |
            ${{ runner.os }}-nextjs-${{ env.CACHE_VERSION }}-

      - name: Build application with optimization
        run: |
          # Enable production optimizations
          export NODE_ENV=production
          export NEXT_TELEMETRY_DISABLED=1
          
          echo "Starting optimized build..."
          npm run build
          
          # Verify build output
          if [ ! -d "out" ]; then
            echo "‚ùå Build failed - no output directory"
            exit 1
          fi
          
          echo "‚úÖ Build completed successfully"

      - name: Bundle analysis
        run: |
          # Analyze bundle size and report
          echo "=== Bundle Analysis ===" > bundle-report.txt
          echo "Build timestamp: $(date -u)" >> bundle-report.txt
          
          if [ -d "out/_next/static" ]; then
            echo "Static assets:" >> bundle-report.txt
            find out/_next/static -name "*.js" -exec ls -lh {} \; | awk '{print $5, $9}' >> bundle-report.txt
            
            # Check for large bundles (>500KB warning)
            LARGE_FILES=$(find out/_next/static -name "*.js" -size +500k)
            if [ -n "$LARGE_FILES" ]; then
              echo "‚ö†Ô∏è Large bundle files detected:" >> bundle-report.txt
              echo "$LARGE_FILES" >> bundle-report.txt
            fi
          fi

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: webapp-build
          path: |
            out/
            bundle-report.txt
          retention-days: 30

  security-scan:
    name: Security & Performance Audit
    runs-on: ubuntu-latest
    needs: build-optimization
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: webapp-build

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install Lighthouse CI
        run: npm install -g @lhci/cli@0.12.x

      - name: Security headers check
        run: |
          echo "Checking security headers in Next.js config..."
          
          # Verify security configurations exist
          if grep -q "helmet\|security" next.config.js; then
            echo "‚úÖ Security configurations found"
          else
            echo "‚ö†Ô∏è Consider adding security headers"
          fi

      - name: Dependency vulnerability check
        run: |
          # Check for known vulnerabilities
          npx audit-ci --config audit-ci.json || echo "‚ö†Ô∏è Vulnerabilities detected"

      - name: Upload security scan results
        uses: actions/upload-artifact@v4
        with:
          name: security-scan-results
          path: |
            security-report.json
          retention-days: 7

  deploy-staging:
    name: Deploy to Staging Environment
    runs-on: ubuntu-latest
    needs: [unit-tests, build-optimization, security-scan]
    if: github.ref == 'refs/heads/main' && (inputs.deploy_environment == 'staging' || github.event_name == 'pull_request')
    environment:
      name: staging
      url: ${{ steps.deploy.outputs.page_url }}
    
    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: webapp-build

      - name: Setup Pages (Staging)
        uses: actions/configure-pages@v4

      - name: Deploy to staging
        id: deploy
        uses: actions/upload-pages-artifact@v3
        with:
          path: './out'

      - name: Staging health check
        run: |
          echo "Staging deployment completed"
          echo "Health check would verify staging environment here"

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [unit-tests, build-optimization, security-scan]
    if: github.ref == 'refs/heads/main' && inputs.deploy_environment != 'staging'
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    
    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: webapp-build

      - name: Setup Pages (Production)
        uses: actions/configure-pages@v4

      - name: Upload to GitHub Pages
        uses: actions/upload-pages-artifact@v3
        with:
          path: './out'

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4

      - name: Post-deployment verification
        run: |
          echo "Production deployment completed"
          echo "Deployment URL: ${{ steps.deployment.outputs.page_url }}"

  post-deploy-verification:
    name: Post-Deployment Verification
    runs-on: ubuntu-latest
    needs: [deploy-production]
    if: success()
    
    steps:
      - name: Wait for deployment propagation
        run: sleep 30

      - name: Production health check
        env:
          SITE_URL: https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}
        run: |
          echo "Verifying production deployment: $SITE_URL"
          
          MAX_RETRIES=5
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            RETRY_COUNT=$((RETRY_COUNT + 1))
            echo "Health check attempt $RETRY_COUNT/$MAX_RETRIES"
            
            RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 10 --max-time 30 "$SITE_URL" || echo "000")
            
            if [ "$RESPONSE" = "200" ]; then
              echo "‚úÖ Production health check passed"
              exit 0
            fi
            
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              echo "Retrying in 10 seconds..."
              sleep 10
            fi
          done
          
          echo "‚ùå Production health check failed after $MAX_RETRIES attempts"
          exit 1

      - name: Performance baseline check
        env:
          SITE_URL: https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}
        run: |
          echo "Running basic performance check..."
          
          # Measure key performance metrics
          LOAD_TIME=$(curl -w "%{time_total}" -s -o /dev/null "$SITE_URL" || echo "timeout")
          TTFB=$(curl -w "%{time_starttransfer}" -s -o /dev/null "$SITE_URL" || echo "timeout")
          
          echo "Load Time: ${LOAD_TIME}s"
          echo "Time to First Byte: ${TTFB}s"
          
          # Set performance thresholds
          if (( $(echo "$LOAD_TIME > 3.0" | bc -l) )); then
            echo "‚ö†Ô∏è Load time exceeds 3s threshold"
          else
            echo "‚úÖ Load time within acceptable limits"
          fi

  pipeline-reporting:
    name: Pipeline Status Report
    runs-on: ubuntu-latest
    needs: [code-quality, unit-tests, build-optimization, security-scan, deploy-production, post-deploy-verification]
    if: always()
    
    steps:
      - name: Generate pipeline report
        run: |
          echo "=== CI/CD Pipeline Report ==="
          echo "Timestamp: $(date -u)"
          echo "Commit: ${{ github.sha }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "Trigger: ${{ github.event_name }}"
          echo ""
          echo "Job Results:"
          echo "- Code Quality: ${{ needs.code-quality.result }}"
          echo "- Unit Tests: ${{ needs.unit-tests.result }}"
          echo "- Build: ${{ needs.build-optimization.result }}"
          echo "- Security Scan: ${{ needs.security-scan.result }}"
          echo "- Deploy Production: ${{ needs.deploy-production.result }}"
          echo "- Post-Deploy Check: ${{ needs.post-deploy-verification.result }}"
          
          # Calculate success rate
          TOTAL=6
          SUCCESS=0
          [[ "${{ needs.code-quality.result }}" == "success" ]] && SUCCESS=$((SUCCESS + 1))
          [[ "${{ needs.unit-tests.result }}" == "success" ]] && SUCCESS=$((SUCCESS + 1))
          [[ "${{ needs.build-optimization.result }}" == "success" ]] && SUCCESS=$((SUCCESS + 1))
          [[ "${{ needs.security-scan.result }}" == "success" ]] && SUCCESS=$((SUCCESS + 1))
          [[ "${{ needs.deploy-production.result }}" == "success" ]] && SUCCESS=$((SUCCESS + 1))
          [[ "${{ needs.post-deploy-verification.result }}" == "success" ]] && SUCCESS=$((SUCCESS + 1))
          
          SUCCESS_RATE=$((SUCCESS * 100 / TOTAL))
          echo "Pipeline Success Rate: $SUCCESS_RATE%"

      - name: Create failure alert
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            const title = 'üö® CI/CD Pipeline Failure';
            const body = `## CI/CD Pipeline Failure Report
            
            **Timestamp:** ${new Date().toISOString()}
            **Commit:** ${context.sha}
            **Branch:** ${context.ref}
            **Pipeline Run:** ${context.runId}
            
            ### Failed Jobs
            - Code Quality: ${{ needs.code-quality.result }}
            - Unit Tests: ${{ needs.unit-tests.result }}
            - Build: ${{ needs.build-optimization.result }}
            - Security Scan: ${{ needs.security-scan.result }}
            - Deploy Production: ${{ needs.deploy-production.result }}
            - Post-Deploy Check: ${{ needs.post-deploy-verification.result }}
            
            ### Impact
            - Production deployment may be blocked
            - User-facing features may be affected
            - Quality gates not met
            
            ### Immediate Actions
            1. Review failed job logs
            2. Address failing tests or build issues
            3. Verify dependencies and configurations
            4. Re-run pipeline after fixes
            
            [View Pipeline Run](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})
            `;
            
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['critical', 'cicd-failure', 'deployment', 'automated']
            });